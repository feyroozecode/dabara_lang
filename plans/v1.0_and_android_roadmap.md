# Dabara Lang: v1.0 Roadmap & Android Mobile App Strategy

**Created**: 2026-01-19
**Current Version**: v0.3.0
**Target**: v1.0.0 Production Release + Android App

---

## PART 1: HIGH-PRIORITY NEXT STEPS TO v1.0

### Executive Summary

**Current Status**: Dabara v0.3.0 has solid fundamentals but needs critical fixes and production features
**Time to v1.0**: 4-5 months of focused development
**Blocking Issues**: 12 failing tests, no standard library, no module system

---

## Critical Path Items (MUST-HAVE for v1.0)

### 1. FIX FAILING TEST SUITE ⚠️ URGENT
**Priority**: CRITICAL
**Timeline**: 1-2 days
**Status**: 12 tests failing

**Problem**: Tests expect old operator keywords (`kara`, `rage`, `ninka`, `raba`) that conflict with method names. Language now uses symbolic operators (`+`, `-`, `*`, `/`).

**Action Items**:
- [ ] Update all failing tests to use symbolic operators
- [ ] Remove references to old keyword operators
- [ ] Verify all 41 tests pass
- [ ] Add regression tests for operator precedence

**Files to Update**:
- [tests/integration_tests.rs](../tests/integration_tests.rs)
- [tests/test_functions.rs](../tests/test_functions.rs)

---

### 2. BUILD COMPREHENSIVE STANDARD LIBRARY
**Priority**: CRITICAL
**Timeline**: 3-4 weeks

**Current State**: Only 10 built-in methods exist (list/string methods). No standalone functions.

**Required Modules**:

#### Math Module (`sunan_lissafi` / math)
```hausa
// Basic arithmetic
abs(lamba)           // Absolute value
sqrt(lamba)          // Square root
pow(base, exp)       // Power
min(a, b, ...)       // Minimum
max(a, b, ...)       // Maximum

// Rounding
floor(lamba)         // Round down
ceil(lamba)          // Round up
round(lamba)         // Round to nearest

// Trigonometry
sin(kwana), cos(kwana), tan(kwana)
asin(x), acos(x), atan(x)

// Constants
DABARAN_PI = 3.14159265358979323846
DABARAN_E = 2.71828182845904523536
```

#### Type Conversion Module (`canja_nau'i` / convert)
```hausa
int(abu)             // Convert to integer
float(abu)           // Convert to float
string(abu)          // Convert to string
list(abu)            // Convert to list
bool(abu)            // Convert to boolean
```

#### String Utilities (`kayan_rubutu` / string_utils)
```hausa
contains(rubutu, substring)    // Check substring
starts_with(rubutu, awali)     // Starts with
ends_with(rubutu, karshe)      // Ends with
replace(rubutu, tsoho, sabo)   // Replace text
trim(rubutu)                   // Remove whitespace
```

#### List Utilities (`kayan_jeri` / list_utils)
```hausa
sort(jeri)           // Sort list
reverse(jeri)        // Reverse list
filter(jeri, aiki)   // Filter with function
map(jeri, aiki)      // Transform elements
sum(jeri)            // Sum all numbers
```

**Implementation Strategy**:
1. Create `src/stdlib/` directory
2. Implement each module as separate file
3. Register functions in interpreter's global scope
4. Add comprehensive tests for each function
5. Document all functions in Hausa/French

**Testing Requirements**:
- Unit tests for each function
- Edge case testing (null, empty, invalid inputs)
- Performance benchmarks
- Cross-platform compatibility

---

### 3. IMPLEMENT MODULE SYSTEM
**Priority**: HIGH
**Timeline**: 2-3 weeks

**Current Limitation**: Single-file execution only. No code reuse or organization.

**Required Features**:

#### Basic Import/Export
```hausa
// File: kayan_aiki.ha (utilities.ha)
aiki tara(a, b) {
    mayar a + b
}

aiki rage(a, b) {
    mayar a - b
}

// Export functions
fitar tara, rage

// File: babban_fayil.ha (main.ha)
shigo tara, rage daga "kayan_aiki"

rubuta tara(5, 3)  // Output: 8
```

#### Module Resolution
- [ ] Relative paths: `shigo X daga "./file.ha"`
- [ ] Absolute paths: `shigo X daga "/path/to/file.ha"`
- [ ] Standard library: `shigo lissafi` (no path = stdlib)
- [ ] Circular dependency detection

#### Implementation Tasks
1. Extend AST with Import/Export nodes
2. Add module loader in interpreter
3. Implement scope isolation per module
4. Add module caching
5. Support multi-file projects

**Files to Create**:
- `src/module_loader.rs` (new)
- `src/module_cache.rs` (new)

**Files to Modify**:
- [src/parser.rs](../src/parser.rs) - Add import/export parsing
- [src/interpreter.rs](../src/interpreter.rs) - Module loading logic
- [src/lexer.rs](../src/lexer.rs) - Add keywords `shigo`, `fitar`, `daga`

---

### 4. ADD ERROR HANDLING SYSTEM
**Priority**: HIGH
**Timeline**: 2-3 weeks

**Current State**: No try-catch, errors crash program immediately.

**Required Features**:

#### Try-Catch-Finally
```hausa
gwada {
    // Risky code
    naɗa lambar = 10 / 0
} kama (kuskure) {
    rubuta "Kuskure ya faru: " + kuskure
} a ƙarshe {
    // Always runs
    rubuta "Cleanup code"
}
```

#### Result Types
```hausa
aiki raba_lafiya(a, b) {
    idan b == 0 {
        mayar Kuskure("Cannot divide by zero")
    }
    mayar Daidai(a / b)
}

naɗa sakamako = raba_lafiya(10, 0)
idan sakamako.gaskiya {
    rubuta sakamako.darajar
} amma {
    rubuta sakamako.kuskure
}
```

#### Stack Traces
```
Kuskure: Division by zero
  a layi 15 cikin fayil program.ha
  a layi 8 cikin aiki 'calculate'
  a layi 3 cikin aiki 'main'
```

**Implementation Tasks**:
1. Add exception types to AST
2. Implement try-catch parsing
3. Add error propagation in interpreter
4. Generate stack traces with line numbers
5. Localize error messages (Hausa + French)

**New Keywords**:
- `gwada` (try)
- `kama` (catch)
- `a ƙarshe` (finally)
- `jefa` (throw) - for custom errors

---

### 5. BUILD REPL (INTERACTIVE SHELL)
**Priority**: MEDIUM-HIGH
**Timeline**: 1-2 weeks

**Current State**: File-only execution. No interactive environment.

**Target Experience**:
```bash
$ dabara
Dabara v1.0.0 - Hausa Programming Language
Sannu! Rubuta 'taimako' don samun taimako.

>>> naɗa x = 10
>>> x + 5
15
>>> aiki square(n) { mayar n * n }
>>> square(7)
49
>>> taimako
Available commands:
  taimako - Show this help
  fita    - Exit REPL
  ...
```

**Features**:
- [ ] Line-by-line code execution
- [ ] Command history (up/down arrows)
- [ ] Multi-line input support
- [ ] Variable persistence across lines
- [ ] Syntax highlighting (optional)
- [ ] Auto-completion (nice-to-have)

**Implementation**:
1. Use `rustyline` crate for line editing
2. Create REPL loop in [src/main.rs](../src/main.rs)
3. Maintain persistent interpreter state
4. Add special commands (help, exit, clear)

---

### 6. COMPLETE BREAK/CONTINUE IMPLEMENTATION
**Priority**: MEDIUM
**Timeline**: 3-5 days

**Current State**: Parsed but not executed (returns TODO error).

**Required**:
```hausa
// Break example
maimaita (i < 10) {
    idan i == 5 {
        tsaya  // break
    }
    rubuta i
    naɗa i = i + 1
}

// Continue example
ga i cikin [1, 2, 3, 4, 5] {
    idan i == 3 {
        cigaba  // continue
    }
    rubuta i
}
```

**Implementation**:
- [ ] Add LoopControl enum in interpreter
- [ ] Propagate break/continue through call stack
- [ ] Handle in both while and for loops
- [ ] Test nested loops with break/continue

**Files to Modify**:
- [src/interpreter.rs](../src/interpreter.rs:693) - Execute break/continue

---

### 7. ENHANCE DOCUMENTATION
**Priority**: MEDIUM
**Timeline**: 1-2 weeks

**Current Gaps**:
- ❌ No API reference documentation
- ❌ No architecture documentation
- ❌ No standard library reference

**Deliverables**:

#### 1. API Documentation
- Auto-generate from code comments
- Use `cargo doc` for stdlib
- Create web-friendly version

#### 2. Standard Library Reference
```markdown
# Dabara Standard Library Reference

## Math Module (lissafi)

### abs(lamba) → lamba
Returns absolute value of a number.

**Parameters**:
- `lamba` (int|float): Input number

**Returns**: Non-negative number

**Examples**:
```hausa
abs(-5)    // 5
abs(3.14)  // 3.14
```
```

#### 3. Architecture Documentation
- Lexer → Parser → Interpreter flow diagram
- AST node types
- Interpreter internals
- Module system design

#### 4. Tutorial Updates
- Update existing tutorials for v1.0 features
- Add module system tutorial
- Add error handling tutorial
- Add stdlib usage examples

---

### 8. PERFORMANCE OPTIMIZATION
**Priority**: MEDIUM
**Timeline**: 2-4 weeks

**Current State**: Direct AST interpretation (slowest approach).

**Optimization Strategies**:

#### Phase 1: Profile & Quick Wins (Week 1)
- [ ] Add performance benchmarks
- [ ] Profile existing code
- [ ] Optimize hot paths in interpreter
- [ ] Cache repeated operations

#### Phase 2: Bytecode Compiler (Week 2-3)
- [ ] Design bytecode instruction set
- [ ] Implement AST → Bytecode compiler
- [ ] Build stack-based VM
- [ ] Test performance gains

#### Phase 3: Advanced (Week 4+)
- [ ] Constant folding
- [ ] Dead code elimination
- [ ] Inline small functions
- [ ] Consider JIT compilation (future)

**Expected Performance**:
- Target: 2-5x faster than current
- Comparable to Python/Ruby for typical workloads

---

### 9. COMPREHENSIVE TESTING SUITE
**Priority**: MEDIUM
**Timeline**: 1-2 weeks

**Current State**: 41 tests (29 passing, 12 failing).

**Target**: 200+ tests with 80%+ code coverage

**Test Categories**:

#### Unit Tests (per module)
- Lexer tokenization
- Parser AST generation
- Interpreter execution
- Standard library functions
- Module loading

#### Integration Tests
- Complete programs
- Multi-file projects
- Error handling flows
- REPL interactions

#### Property-Based Tests
- Use `proptest` crate
- Random input fuzzing
- Edge case discovery

#### Performance Tests
- Benchmark suite
- Regression detection
- Memory usage tracking

**Files to Create**:
- `tests/stdlib_tests.rs` (new)
- `tests/module_tests.rs` (new)
- `tests/error_handling_tests.rs` (new)
- `benches/performance.rs` (new)

---

## v1.0 Milestone Definition

### Feature Completeness Checklist

#### Language Features ✓
- [x] Variables, data types (int, float, string, bool, list)
- [x] Operators (arithmetic, comparison, logical)
- [x] Control flow (if/else, loops)
- [x] Functions (recursion, parameters, return)
- [ ] Error handling (try-catch-finally)
- [ ] Break/continue (complete implementation)
- [ ] Standard library (comprehensive)
- [ ] Module system (import/export)

#### Developer Experience ✓
- [ ] REPL (interactive shell)
- [ ] Clear error messages with line numbers
- [ ] Stack traces
- [ ] Documentation (complete)
- [ ] Examples and tutorials

#### Quality Assurance ✓
- [ ] All tests passing (0 failures)
- [ ] 80%+ code coverage
- [ ] Performance benchmarks
- [ ] Multi-platform testing (Linux, Mac, Windows)

#### Production Readiness ✓
- [ ] Optimized performance (bytecode VM optional)
- [ ] Memory safety
- [ ] Security review
- [ ] Versioning and releases

---

## v1.0 Development Timeline

### Month 1: Foundation & Fixes
**Week 1-2**:
- ✅ Fix all 12 failing tests
- ✅ Implement break/continue
- ✅ Set up stdlib structure

**Week 3-4**:
- ✅ Build core stdlib (math, type conversion)
- ✅ Start module system design
- ✅ Basic REPL implementation

### Month 2: Core Features
**Week 5-6**:
- ✅ Complete stdlib (string, list utilities)
- ✅ Implement module loader
- ✅ Add import/export syntax

**Week 7-8**:
- ✅ Error handling system (try-catch)
- ✅ Stack trace generation
- ✅ Module testing

### Month 3: Polish & Documentation
**Week 9-10**:
- ✅ REPL enhancements
- ✅ Documentation generation
- ✅ Tutorial updates

**Week 11-12**:
- ✅ Performance optimization
- ✅ Bytecode compiler (if time permits)
- ✅ Benchmark suite

### Month 4: Testing & Quality
**Week 13-14**:
- ✅ Comprehensive test suite (200+ tests)
- ✅ Bug fixes from testing
- ✅ Cross-platform testing

**Week 15-16**:
- ✅ Security review
- ✅ Performance validation
- ✅ Final documentation polish

### Month 5: Release Preparation
**Week 17-18**:
- ✅ Beta testing with community
- ✅ Bug fixes from beta feedback
- ✅ Release notes and changelog

**Week 19-20**:
- ✅ Final release preparation
- ✅ v1.0.0 launch
- ✅ Announcement and promotion

---

## Success Criteria for v1.0 Release

### Technical Metrics
- ✅ **Zero test failures**: All 200+ tests pass
- ✅ **Performance**: At least 2x faster than v0.3.0
- ✅ **Stability**: No crashes on valid programs
- ✅ **Platform support**: Linux, macOS, Windows tested

### Feature Metrics
- ✅ **Standard library**: 50+ functions across 5+ modules
- ✅ **Error handling**: Try-catch fully functional
- ✅ **Module system**: Multi-file projects work
- ✅ **REPL**: Stable interactive environment

### Quality Metrics
- ✅ **Documentation**: 100% stdlib documented
- ✅ **Code coverage**: 80%+ test coverage
- ✅ **Examples**: 20+ working example programs
- ✅ **Tutorials**: 10+ beginner to advanced guides

---

# PART 2: ANDROID MOBILE APP ROADMAP

## Overview

**Goal**: Create an Android app that allows users to write, run, and learn Dabara programming on mobile devices.

**Target Users**:
- Students in Hausa-speaking regions (Nigeria, Niger, etc.)
- Programming learners without computer access
- Mobile-first developers
- Educational institutions

**Key Challenge**: Dabara interpreter is written in Rust; Android apps typically use Java/Kotlin.

---

## Architecture Options

### Option 1: WebAssembly (WASM) Bridge ⭐ RECOMMENDED
**Timeline**: 2-3 months
**Difficulty**: Medium
**Performance**: Good

**Architecture**:
```
Android App (Kotlin/Java)
    ↓ JavaScript Bridge
WebView with WASM
    ↓ WASM Binary
Dabara Interpreter (compiled to WASM)
```

**Advantages**:
- ✅ No need to rewrite interpreter
- ✅ Cross-platform (works on web too)
- ✅ Easy updates (swap WASM file)
- ✅ Good performance with WASM
- ✅ Can reuse web-based editor

**Disadvantages**:
- ⚠️ Requires WebView (adds size)
- ⚠️ JavaScript bridge overhead
- ⚠️ Limited native Android integration

---

### Option 2: JNI (Java Native Interface)
**Timeline**: 3-4 months
**Difficulty**: Hard
**Performance**: Excellent

**Architecture**:
```
Android App (Kotlin/Java)
    ↓ JNI
Native Library (.so file)
    ↓ Rust FFI
Dabara Interpreter (compiled to native ARM)
```

**Advantages**:
- ✅ Native performance
- ✅ Full Android API access
- ✅ Smaller app size (no WebView)
- ✅ Offline capable

**Disadvantages**:
- ❌ Complex JNI bindings
- ❌ Must maintain two codebases
- ❌ Difficult debugging
- ❌ Platform-specific builds

---

### Option 3: React Native + WASM
**Timeline**: 2 months
**Difficulty**: Medium
**Performance**: Good

**Architecture**:
```
React Native App (JavaScript)
    ↓ React Native Bridge
WASM Module
    ↓
Dabara Interpreter
```

**Advantages**:
- ✅ Cross-platform (iOS + Android)
- ✅ Fast development
- ✅ Rich component ecosystem
- ✅ Hot reload for UI

**Disadvantages**:
- ⚠️ Large app size
- ⚠️ React Native overhead
- ⚠️ Bridge performance issues

---

## RECOMMENDED APPROACH: WebAssembly Strategy

### Phase 1: Build WASM Interpreter (4-6 weeks)

#### Step 1.1: Set Up WASM Build
```bash
# Install wasm-pack
cargo install wasm-pack

# Add wasm32 target
rustup target add wasm32-unknown-unknown

# Build WASM binary
wasm-pack build --target web
```

**Tasks**:
- [ ] Configure Cargo.toml for WASM
- [ ] Add wasm-bindgen dependencies
- [ ] Remove incompatible dependencies (e.g., filesystem access)
- [ ] Test WASM build locally

**Files to Modify**:
- [Cargo.toml](../Cargo.toml) - Add wasm features
- [src/main.rs](../src/main.rs) - Add WASM entry points
- Create `src/wasm.rs` for WASM-specific code

---

#### Step 1.2: Create JavaScript API
```javascript
// dabara-wasm.js
import init, { run_dabara_code } from './dabara.js';

await init();

// Execute Dabara code
const result = run_dabara_code(`
    naɗa x = 10
    rubuta x * 2
`);

console.log(result); // Output: 20
```

**Required Rust Functions**:
```rust
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn run_dabara_code(source: &str) -> String {
    // Run interpreter
    // Capture output
    // Return result
}

#[wasm_bindgen]
pub fn tokenize(source: &str) -> JsValue {
    // Return tokens as JSON
}

#[wasm_bindgen]
pub fn parse(source: &str) -> JsValue {
    // Return AST as JSON
}
```

**Tasks**:
- [ ] Implement WASM bindings
- [ ] Capture print output
- [ ] Handle errors gracefully
- [ ] Export functions to JavaScript

---

#### Step 1.3: Build Web-Based IDE
```html
<!DOCTYPE html>
<html>
<head>
    <title>Dabara Playground</title>
    <style>
        #editor { width: 100%; height: 400px; }
        #output { background: #000; color: #0f0; padding: 10px; }
    </style>
</head>
<body>
    <h1>Dabara Web Playground</h1>
    <textarea id="editor">naɗa sunan = "Ahmad"
rubuta "Sannu " + sunan</textarea>
    <button onclick="runCode()">Run (Gudanar)</button>
    <pre id="output"></pre>

    <script type="module">
        import init, { run_dabara_code } from './dabara.js';
        await init();

        window.runCode = function() {
            const code = document.getElementById('editor').value;
            const result = run_dabara_code(code);
            document.getElementById('output').textContent = result;
        };
    </script>
</body>
</html>
```

**Features**:
- [ ] Code editor (syntax highlighting with CodeMirror)
- [ ] Run button
- [ ] Output display
- [ ] Error messages
- [ ] Example programs dropdown
- [ ] Save/load code (localStorage)

**Technologies**:
- CodeMirror 6 (editor)
- Vite (build tool)
- TailwindCSS (styling)

---

### Phase 2: Build Android App (6-8 weeks)

#### Step 2.1: Set Up Android Project
```bash
# Create new Android project
# Use Android Studio
# Language: Kotlin
# Minimum SDK: API 24 (Android 7.0)
```

**Project Structure**:
```
DabaraApp/
├── app/
│   ├── src/
│   │   ├── main/
│   │   │   ├── kotlin/
│   │   │   │   └── com/dabara/
│   │   │   │       ├── MainActivity.kt
│   │   │   │       ├── EditorActivity.kt
│   │   │   │       └── LearnActivity.kt
│   │   │   ├── res/
│   │   │   │   ├── layout/
│   │   │   │   ├── values/
│   │   │   │   └── drawable/
│   │   │   └── assets/
│   │   │       └── dabara-wasm/
│   │   │           ├── dabara.wasm
│   │   │           └── dabara.js
│   └── build.gradle
└── build.gradle
```

**Tasks**:
- [ ] Create Android Studio project
- [ ] Set up Kotlin + Material Design 3
- [ ] Configure WebView permissions
- [ ] Add WASM files to assets

---

#### Step 2.2: Implement WebView Integration
```kotlin
// MainActivity.kt
class MainActivity : AppCompatActivity() {
    private lateinit var webView: WebView

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        webView = findViewById(R.id.webview)
        setupWebView()
        loadDabaraIDE()
    }

    private fun setupWebView() {
        webView.settings.apply {
            javaScriptEnabled = true
            domStorageEnabled = true
            allowFileAccess = true
        }

        // Add JavaScript interface
        webView.addJavascriptInterface(
            DabaraInterface(this),
            "Android"
        )
    }

    private fun loadDabaraIDE() {
        webView.loadUrl("file:///android_asset/dabara-ide.html")
    }
}

// DabaraInterface.kt
class DabaraInterface(private val context: Context) {
    @JavascriptInterface
    fun showToast(message: String) {
        Toast.makeText(context, message, Toast.LENGTH_SHORT).show()
    }

    @JavascriptInterface
    fun saveCode(code: String, filename: String) {
        // Save to internal storage
        context.openFileOutput(filename, Context.MODE_PRIVATE).use {
            it.write(code.toByteArray())
        }
    }

    @JavascriptInterface
    fun loadCode(filename: String): String {
        return context.openFileInput(filename).bufferedReader().use {
            it.readText()
        }
    }
}
```

**Tasks**:
- [ ] Set up WebView with WASM support
- [ ] Create JavaScript ↔ Android bridge
- [ ] Implement file save/load
- [ ] Handle permissions
- [ ] Test on real device

---

#### Step 2.3: Build Native UI
```kotlin
// Main Screen - Project List
@Composable
fun ProjectListScreen() {
    Column {
        TopAppBar(title = { Text("Dabara Mobile") })

        LazyColumn {
            items(projects) { project ->
                ProjectCard(
                    name = project.name,
                    lastModified = project.lastModified,
                    onClick = { openEditor(project) }
                )
            }
        }

        FloatingActionButton(
            onClick = { createNewProject() }
        ) {
            Icon(Icons.Default.Add, "New Project")
        }
    }
}

// Editor Screen
@Composable
fun EditorScreen(project: Project) {
    Column {
        TopAppBar(
            title = { Text(project.name) },
            actions = {
                IconButton(onClick = { runCode() }) {
                    Icon(Icons.Default.PlayArrow, "Run")
                }
            }
        )

        // WebView with code editor
        AndroidView(factory = { context ->
            WebView(context).apply {
                loadEditor(project.code)
            }
        })

        // Output panel
        OutputPanel(output = outputState.value)
    }
}
```

**Features**:
- [ ] Project management (list, create, delete)
- [ ] Code editor (WebView with CodeMirror)
- [ ] Run button
- [ ] Output panel
- [ ] File save/load
- [ ] Settings screen

**UI Components**:
- Material Design 3
- Jetpack Compose
- Navigation Component
- Room Database (for projects)

---

#### Step 2.4: Add Learning Features
```kotlin
// Tutorial Screen
@Composable
fun TutorialScreen() {
    Column {
        TopAppBar(title = { Text("Koyan Dabara (Learn)") })

        LazyColumn {
            items(tutorials) { tutorial ->
                TutorialCard(
                    title = tutorial.title,
                    description = tutorial.description,
                    progress = tutorial.progress,
                    onClick = { openTutorial(tutorial) }
                )
            }
        }
    }
}

// Interactive Tutorial
@Composable
fun TutorialDetailScreen(tutorial: Tutorial) {
    Column {
        // Tutorial content (markdown)
        MarkdownText(tutorial.content)

        // Interactive code exercise
        CodeExercise(
            challenge = tutorial.challenge,
            expectedOutput = tutorial.expectedOutput,
            onComplete = { completeTutorial() }
        )

        // Next button
        Button(onClick = { nextTutorial() }) {
            Text("Na gaba (Next)")
        }
    }
}
```

**Tutorial Content**:
- [ ] Convert existing tutorials to JSON
- [ ] Add interactive exercises
- [ ] Progress tracking
- [ ] Certificates/badges
- [ ] Quizzes

**Tutorial Structure**:
```json
{
  "id": "tutorial_01",
  "title": "Variables da Printing",
  "titleHausa": "Masu Canjawa da Buga",
  "description": "Learn how to create variables and print output",
  "sections": [
    {
      "type": "text",
      "content": "## Variables\n\nIn Dabara, you create variables with `naɗa`..."
    },
    {
      "type": "exercise",
      "challenge": "Create a variable called 'sunan' with your name and print it",
      "startingCode": "// Write your code here\n",
      "expectedOutput": "Your name",
      "hint": "Use naɗa sunan = \"Your Name\""
    }
  ],
  "nextTutorial": "tutorial_02"
}
```

---

#### Step 2.5: Offline Support
```kotlin
// Cache all tutorials and examples
class DabaraRepository(private val context: Context) {

    fun cacheTutorials() {
        val tutorials = loadTutorialsFromAssets()
        saveTutorialsToDatabase(tutorials)
    }

    fun cacheExamples() {
        val examples = loadExamplesFromAssets()
        saveExamplesToDatabase(examples)
    }

    fun getTutorial(id: String): Tutorial {
        return database.tutorialDao().getTutorial(id)
    }
}
```

**Offline Features**:
- [ ] All tutorials stored locally
- [ ] All examples accessible offline
- [ ] Code execution works offline (WASM)
- [ ] Only updates require internet

---

### Phase 3: Testing & Polish (3-4 weeks)

#### Step 3.1: Testing
- [ ] Unit tests (Kotlin code)
- [ ] UI tests (Espresso/Compose)
- [ ] WASM integration tests
- [ ] Manual testing on devices:
  - Samsung (Android 10+)
  - Pixel (Android 12+)
  - Low-end devices (2GB RAM)
  - Tablets
- [ ] Performance testing
- [ ] Battery usage testing

---

#### Step 3.2: Localization
```xml
<!-- res/values/strings.xml (English) -->
<resources>
    <string name="app_name">Dabara Mobile</string>
    <string name="run">Run</string>
    <string name="save">Save</string>
</resources>

<!-- res/values-ha/strings.xml (Hausa) -->
<resources>
    <string name="app_name">Dabara Wayar Hannu</string>
    <string name="run">Gudanar</string>
    <string name="save">Adana</string>
</resources>

<!-- res/values-fr/strings.xml (French) -->
<resources>
    <string name="app_name">Dabara Mobile</string>
    <string name="run">Exécuter</string>
    <string name="save">Enregistrer</string>
</resources>
```

**Languages**:
- [ ] Hausa (primary)
- [ ] English
- [ ] French
- [ ] Arabic (optional - used in Niger/Northern Nigeria)

---

#### Step 3.3: Polish
- [ ] App icon (professional design)
- [ ] Splash screen
- [ ] Animations (smooth transitions)
- [ ] Dark mode support
- [ ] Tablet layout optimization
- [ ] Accessibility (TalkBack support)
- [ ] Keyboard shortcuts
- [ ] Code snippets
- [ ] Share code feature
- [ ] Export to .ha file

---

### Phase 4: Release (2-3 weeks)

#### Step 4.1: Google Play Store Preparation
```
App Details:
- Name: Dabara - Hausa Programming
- Package: com.dabara.mobile
- Category: Education
- Age Rating: Everyone
- Languages: Hausa, English, French
- Countries: Nigeria, Niger, Ghana, Cameroon (primary)
- Price: Free
```

**Store Listing**:
- [ ] App description (all languages)
- [ ] Screenshots (5-8)
- [ ] Feature graphic
- [ ] Video preview
- [ ] Privacy policy
- [ ] Terms of service

---

#### Step 4.2: Beta Testing
- [ ] Internal testing (10 people)
- [ ] Closed beta (100 people)
- [ ] Open beta (unlimited)
- [ ] Collect feedback
- [ ] Fix critical bugs
- [ ] Performance optimization

---

#### Step 4.3: Launch
- [ ] Submit to Google Play Store
- [ ] Wait for review (3-7 days)
- [ ] Launch announcement
- [ ] Social media promotion
- [ ] Partner with schools
- [ ] Press release

---

## Android App Features Summary

### Version 1.0 (MVP)
- ✅ Code editor with syntax highlighting
- ✅ Run Dabara code (via WASM)
- ✅ Save/load projects
- ✅ Basic tutorials (10+)
- ✅ Example programs (20+)
- ✅ Offline support
- ✅ Hausa/English/French UI

### Version 1.1 (Post-Launch)
- [ ] Code sharing (QR code, link)
- [ ] Community examples
- [ ] Achievements/badges
- [ ] Interactive challenges
- [ ] Code playground
- [ ] Teacher dashboard

### Version 2.0 (Future)
- [ ] Collaboration (pair programming)
- [ ] Cloud sync
- [ ] AI-powered code completion
- [ ] Voice coding (Hausa)
- [ ] Video tutorials
- [ ] Live coding sessions

---

## Technical Specifications

### Minimum Requirements
- **Android Version**: 7.0 (API 24)
- **RAM**: 2GB
- **Storage**: 50MB
- **Screen**: 480x800 (small phone support)

### Recommended
- **Android Version**: 10+ (API 29)
- **RAM**: 4GB
- **Storage**: 100MB
- **Screen**: 720x1280 or higher

### App Size
- **WASM binary**: ~2-3 MB
- **UI/Assets**: ~5-10 MB
- **Tutorials**: ~3-5 MB
- **Total**: ~15-20 MB

### Performance Targets
- **Cold start**: < 2 seconds
- **Code execution**: < 100ms for simple programs
- **Memory usage**: < 150MB
- **Battery**: < 5% per hour of active use

---

## Alternative: iOS Version

### Timeline: 3-4 months (after Android)
### Approach: Same WASM strategy with WKWebView

**Key Differences**:
- Use Swift instead of Kotlin
- WKWebView instead of WebView
- UIKit or SwiftUI for UI
- TestFlight for beta testing
- Apple Developer Program ($99/year)

**Shared Assets**:
- ✅ Same WASM binary
- ✅ Same HTML/CSS/JS editor
- ✅ Same tutorials (JSON format)
- ✅ Same examples

---

## Cost Estimation

### Development Costs
| Item | Cost |
|------|------|
| Developer time (4-5 months @ $50/hr, 160hr/month) | $32,000 - $40,000 |
| Google Play Developer account (one-time) | $25 |
| Domain name (optional) | $10/year |
| Hosting (for web playground) | $5-20/month |
| Apple Developer account (for iOS) | $99/year |
| **Total (Android only)** | **~$32,000 - $40,000** |

### Ongoing Costs
- Google Play hosting: Free
- Updates and maintenance: $500-1000/month
- Server costs (optional): $20-50/month
- Marketing: Variable

### Free/Open Source Alternative
- Volunteer development
- Community contributions
- Sponsorships from organizations
- Educational grants

---

## Marketing & Distribution Strategy

### Target Audience
1. **Students** (age 12-25)
   - Hausa speakers in Nigeria, Niger
   - No computer access
   - Mobile-first users

2. **Teachers** (age 25-50)
   - Computer science educators
   - Need offline teaching tools
   - Limited resources

3. **Self-Learners** (age 18-35)
   - Career switchers
   - Programming enthusiasts
   - Mobile developers

### Marketing Channels
1. **Social Media**
   - Twitter/X (tech community)
   - Facebook (Hausa groups)
   - TikTok (short tutorials)
   - YouTube (full tutorials)

2. **Educational Partnerships**
   - Nigerian universities
   - Niger schools
   - Coding bootcamps
   - NGOs (e.g., Andela, Co-Creation Hub)

3. **App Stores**
   - Google Play Store (primary)
   - Alternative stores (Aptoide, Amazon)

4. **Events**
   - Tech conferences (Nigeria, Niger)
   - Hackathons
   - School workshops
   - Webinars

### Launch Strategy
1. **Pre-Launch (Month -2 to -1)**
   - Create landing page
   - Build email list
   - Social media teaser campaign
   - Partner outreach

2. **Beta Launch (Month 0)**
   - Limited beta (100 users)
   - Collect feedback
   - Fix critical bugs

3. **Public Launch (Month 1)**
   - Press release
   - Social media campaign
   - School partnerships announced
   - Blog post + HackerNews

4. **Post-Launch (Month 2-3)**
   - User feedback implementation
   - Regular updates
   - Community building
   - Content marketing (tutorials, videos)

---

## Success Metrics

### Year 1 Goals
- **Downloads**: 10,000+
- **Active users**: 2,000+
- **Schools**: 20+ partnerships
- **Rating**: 4.5+ stars on Play Store
- **Completion**: 50%+ users complete first tutorial

### Year 2 Goals
- **Downloads**: 50,000+
- **Active users**: 10,000+
- **Schools**: 100+ partnerships
- **Premium features** (optional): 500+ subscribers
- **iOS version**: Launched

### Long-Term Vision
- **1M+ downloads**
- **100K+ active developers**
- **500+ schools** using Dabara
- **Community-driven** content and examples
- **Self-sustaining** ecosystem

---

## Risk Analysis & Mitigation

### Technical Risks
| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| WASM performance issues | High | Low | Benchmark early, optimize |
| WebView compatibility | Medium | Medium | Test on many devices |
| App size too large | Medium | Low | Code splitting, compression |
| Battery drain | High | Low | Performance profiling |

### Business Risks
| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Low adoption | High | Medium | Strong marketing, partnerships |
| Competition | Medium | Low | First-mover advantage |
| Funding shortage | High | Medium | Grants, sponsorships |
| Developer burnout | Medium | Medium | Community contributions |

### Market Risks
| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Limited smartphone access | High | Low | Offline-first design |
| Internet connectivity issues | Medium | High | Full offline support |
| Language preference (English) | Medium | Medium | Bilingual interface |
| Education system resistance | Medium | Medium | Teacher training, free tools |

---

## Conclusion

### v1.0 Next Steps (Prioritized)
1. **Fix failing tests** (Week 1) - CRITICAL
2. **Build standard library** (Week 2-5) - CRITICAL
3. **Implement module system** (Week 6-8) - HIGH
4. **Add error handling** (Week 9-11) - HIGH
5. **Build REPL** (Week 12-13) - MEDIUM
6. **Complete break/continue** (Week 14) - MEDIUM
7. **Performance optimization** (Week 15-17) - MEDIUM
8. **Documentation** (Week 18-19) - MEDIUM
9. **Testing suite** (Week 20-21) - MEDIUM
10. **v1.0 launch** (Week 22) - MILESTONE

### Android App Next Steps (After v1.0)
1. **Build WASM version** (Month 1-1.5) - Phase 1
2. **Create web IDE** (Month 2) - Phase 1
3. **Android app development** (Month 3-4) - Phase 2
4. **Testing & polish** (Month 5) - Phase 3
5. **Beta launch** (Month 5.5) - Phase 4
6. **Public launch** (Month 6) - Phase 4

### Total Timeline
- **v1.0.0 production**: 5 months from now
- **Android app launch**: 6 months after v1.0 (11 months total)
- **iOS app launch**: 3-4 months after Android (14-15 months total)

### Resources Needed
- **1-2 developers** (core team)
- **UI/UX designer** (for mobile app)
- **Technical writer** (documentation)
- **Community manager** (post-launch)
- **Budget**: $32K-40K for Android development

---

**Document Version**: 1.0
**Last Updated**: 2026-01-19
**Next Review**: After v1.0 launch

---

## Quick Reference

### Key Commands
```bash
# Build v1.0
cargo test              # Run tests
cargo build --release   # Build optimized binary
cargo doc --open        # Generate documentation

# Build WASM
wasm-pack build --target web

# Build Android
./gradlew assembleDebug
./gradlew bundleRelease

# Run tests
cargo test
./gradlew test
```

### Key Files
- [Cargo.toml](../Cargo.toml) - Rust configuration
- [src/interpreter.rs](../src/interpreter.rs) - Core interpreter
- [src/parser.rs](../src/parser.rs) - Parser implementation
- [tests/integration_tests.rs](../tests/integration_tests.rs) - Main test suite
- [plans/dabara_evolution_plan.md](./dabara_evolution_plan.md) - Long-term roadmap

### Contact & Resources
- **Repository**: [GitHub](https://github.com/yourusername/dabara_lang)
- **Issues**: [GitHub Issues](https://github.com/yourusername/dabara_lang/issues)
- **Discussions**: [GitHub Discussions](https://github.com/yourusername/dabara_lang/discussions)
- **Email**: dabara@example.com (placeholder)
